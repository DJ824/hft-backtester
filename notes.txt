#pragma once

#include <iostream>
#include <memory>
#include <queue>
#include <vector>
#include <array>
#include <chrono>
#include <cmath>
#include <numeric>
#include <Eigen/Dense>
#include "strategy.h"
#include "orderbook.h"
#include "async_logger.h"

class LinearModelStrategy : public Strategy {
protected:
    static constexpr int MAX_LAG_ = 5;           // Corresponds to 'lags' in R code
    static constexpr int FORECAST_WINDOW_ = 20;  // Corresponds to 'delay' in R code
    static constexpr double THRESHOLD_ = 5;    // Adjusted threshold after standardizing y
    static constexpr double TR_COST = 2;   // Transaction cost from R code
    static constexpr int TRADE_SIZE_ = 1;        // Fixed trade size as in R code

    std::vector<double> model_coefficients_;
    int forecast_window_;
    int max_lag_;
    int position_;             // Position: -1 (short), 0 (flat), 1 (long)
    double entry_price_;       // Price at which current position was entered
    double pnl_;               // Realized PnL
    double fees_;              // Accumulated fees
    double prev_pnl_;          // Previous PnL for logging

    // Scaling parameters for normalization
    double voi_mean_;
    double voi_std_;
    double y_mean_;            // Mean of the response variable y
    double y_std_;             // Standard deviation of y

    // Functions to calculate mean and standard deviation
    double calculate_mean(const std::vector<int32_t>& data) const {
        if (data.empty()) return 0.0;
        double sum = std::accumulate(data.begin(), data.end(), 0.0);
        return sum / data.size();
    }

    double calculate_std(const std::vector<int32_t>& data, double mean) const {
        if (data.size() < 2) return 1.0; // Avoid division by zero
        double accum = 0.0;
        for (double x : data) {
            accum += (x - mean) * (x - mean);
        }
        return std::sqrt(accum / (data.size() - 1));
    }

    double predict_price_change() const {
        if (model_coefficients_.empty()) return 0.0;

        int data_size = static_cast<int>(book_->voi_history_curr_.size());
        if (data_size < max_lag_ + 1) {
            // Not enough data for prediction
            return 0.0;
        }

        // Predict using normalized VOI data and model coefficients
        double prediction = model_coefficients_[0];  // Intercept term
        for (int i = 0; i <= max_lag_; ++i) {
            int index = data_size - 1 - i;
            double normalized_voi = (book_->voi_history_curr_[index] - voi_mean_) / voi_std_;
            prediction += model_coefficients_[i + 1] * normalized_voi;
        }

        // Reverse standardization to get prediction in original units
        prediction = prediction * y_std_ + y_mean_;

        return prediction;
    }

    void execute_trade(bool is_buy, int32_t price) {
        if (is_buy) {
            position_ = 1;
            entry_price_ = price;
            buy_qty_ += TRADE_SIZE_;
        } else {
            position_ = -1;
            entry_price_ = price;
            sell_qty_ += TRADE_SIZE_;
        }
    }

    void close_position(int32_t price) {
        fees_ += TR_COST;

        if (position_ == 1) {
            // Closing a long position
            sell_qty_ += TRADE_SIZE_;
            double trade_pnl = ((price - entry_price_) / 100 ) * POINT_VALUE_ - fees_;
            pnl_ += trade_pnl;
        } else if (position_ == -1) {
            // Closing a short position
            buy_qty_ += TRADE_SIZE_;
            double trade_pnl = ((price - entry_price_) / 100 ) * POINT_VALUE_ - fees_;
            pnl_ += trade_pnl;
        }
        position_ = 0;
        entry_price_ = 0.0;
    }

    void update_theo_values() override {
        // No theoretical values needed in this strategy
    }

    void calculate_pnl() override {
        // PnL is updated in execute_trade and close_position
    }

    void log_stats(const Orderbook& book) override {
        std::string timestamp = book.get_formatted_time_fast();
        int32_t bid = book.get_best_bid_price();
        int32_t ask = book.get_best_ask_price();
        int trade_count = buy_qty_ + sell_qty_;

        logger_->log(timestamp, bid, ask, position_, trade_count, pnl_);
    }

public:
    explicit LinearModelStrategy(DatabaseManager& db_manager, Orderbook* book)
            : Strategy(db_manager, "linear_model_strategy_log.csv", book),
              forecast_window_(FORECAST_WINDOW_), max_lag_(MAX_LAG_), position_(0), entry_price_(0.0),
              pnl_(0.0), fees_(0.0), prev_pnl_(0.0), voi_mean_(0.0), voi_std_(1.0),
              y_mean_(0.0), y_std_(1.0) {
        model_coefficients_.resize(max_lag_ + 2, 0.0);
    }

    void on_book_update() override {
        // Update VOI and mid-price
        book_->calculate_voi_curr();  // Use current VOI calculation
        book_->add_mid_price();

        // Ensure enough data is available
        if (book_->voi_history_curr_.size() < static_cast<size_t>(max_lag_ + 1)) {
            return;
        }

        // Predict price change
        double predicted_change = predict_price_change();

        // Debugging: Print prediction details
        std::cout << "Predicted Change: " << predicted_change << std::endl;

        // Get current bid and ask prices
        int32_t bid_price = book_->get_best_bid_price();
        int32_t ask_price = book_->get_best_ask_price();

        // Trading logic
        if (position_ == 0) {
            // Currently flat
            if (predicted_change >= THRESHOLD_) {
                // Buy to open a long position
                execute_trade(true, ask_price);
                trade_queue_.emplace(true, ask_price);
            } else if (predicted_change <= -THRESHOLD_) {
                // Sell to open a short position
                execute_trade(false, bid_price);
                trade_queue_.emplace(false, bid_price);

            }
        } else if (position_ == 1) {
            // Currently long
            if (predicted_change <= -THRESHOLD_) {
                // Close long and open short position
                close_position(bid_price);
                execute_trade(false, bid_price);
                trade_queue_.emplace(false, bid_price);
            }
        } else if (position_ == -1) {
            // Currently short
            if (predicted_change >= THRESHOLD_) {
                // Close short and open long position
                close_position(ask_price);
                execute_trade(true, ask_price);
                trade_queue_.emplace(true, ask_price);
            }
        }

        // Log stats if PnL has changed
        if (pnl_ != prev_pnl_) {
            log_stats(*book_);
            prev_pnl_ = pnl_;
        }
        std::cout << pnl_ << std::endl;
    }

    void end_of_day() {
        // Close any open positions at the end of the day
        int32_t bid_price = book_->get_best_bid_price();
        int32_t ask_price = book_->get_best_ask_price();

        if (position_ == 1) {
            // Close long position
            close_position(bid_price);
        } else if (position_ == -1) {
            // Close short position
            close_position(ask_price);
        }
    }

    void reset() override {
        Strategy::reset();
        model_coefficients_.clear();
        model_coefficients_.resize(max_lag_ + 2, 0.0);
        position_ = 0;
        entry_price_ = 0.0;
        pnl_ = 0.0;
        fees_ = 0.0;
        prev_pnl_ = 0.0;
        voi_mean_ = 0.0;
        voi_std_ = 1.0;
        y_mean_ = 0.0;
        y_std_ = 1.0;
    }

    void fit_model() override {
        // Ensure enough data is available
        int n = static_cast<int>(book_->voi_history_.size()) - forecast_window_ - max_lag_;
        if (n <= 0) return;

        // Calculate mean and std of VOI for normalization
        voi_mean_ = calculate_mean(book_->voi_history_);
        voi_std_ = calculate_std(book_->voi_history_, voi_mean_);

        // Build feature matrix X and response vector y
        Eigen::MatrixXd X(n, max_lag_ + 2);  // +1 for intercept
        Eigen::VectorXd y(n);

        for (int i = 0; i < n; ++i) {
            X(i, 0) = 1.0;  // Intercept term

            // Lagged VOI features (normalized)
            for (int j = 0; j <= max_lag_; ++j) {
                double normalized_voi = (book_->voi_history_[i + j] - voi_mean_) / voi_std_;
                X(i, j + 1) = normalized_voi;
            }

            // Response variable: average future mid-price change
            double avg_mid_change = 0.0;
            for (int k = 1; k <= forecast_window_; ++k) {
                avg_mid_change += book_->mid_prices_[i + max_lag_ + k] - book_->mid_prices_[i + max_lag_];
            }
            avg_mid_change /= forecast_window_;
            y(i) = avg_mid_change;
        }

        // Standardize y
        y_mean_ = y.mean();
        y_std_ = std::sqrt((y.array() - y_mean_).square().sum() / (y.size() - 1));
        if (y_std_ == 0.0) y_std_ = 1.0;  // Prevent division by zero
        y = (y.array() - y_mean_) / y_std_;

        // Fit linear model using Ordinary Least Squares
        Eigen::VectorXd coeffs = X.colPivHouseholderQr().solve(y);

        // Store the model coefficients
        model_coefficients_ = std::vector<double>(coeffs.data(), coeffs.data() + coeffs.size());

        // Debugging: Print model coefficients
        std::cout << "Model Coefficients after standardizing y:" << std::endl;
        for (size_t i = 0; i < model_coefficients_.size(); ++i) {
            std::cout << "Coeff[" << i << "]: " << model_coefficients_[i] << std::endl;
        }
        std::cout << "y_mean_: " << y_mean_ << ", y_std_: " << y_std_ << std::endl;
    }
};
